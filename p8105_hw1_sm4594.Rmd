---
title: "p8105_hw1_sm4594"
author: "Sophia Miller"
date: "9/15/2019"
output: github_document
---

```{r setup, load_tidyverse}
library(tidyverse)
```

# Problem 1.

Create a data frame comprised of:

* a random sample of size 8 from a standard Normal distribution
* a logical vector indicating whether elements of the sample are greater than 0
* a character vector of length 8
* a factor vector of length 8, with 3 different factor “levels” 

```{r problem1_df}

problem1_df = tibble(
  norm_samp = rnorm(8),
  norm_samp_pos = norm_samp > 0,
  vec_char = c("This", "is", "the", "first", "data", "science", "homework", "assignment"),
  vec_factor = factor(c("one", "two", "three", "one", "two", "three", "one", "two"))
)
```

Take the mean of each variable in the data frame above:

```{r means}

  mean(pull(problem1_df, norm_samp))

  mean(pull(problem1_df, norm_samp_pos))

  mean(pull(problem1_df, vec_char))

  mean(pull(problem1_df, vec_factor))
  
``` 
We are able to take the mean of the random sample as well as the logical vector, but we are unable to take the mean of the character and factor vectors.

Convert logical, character, and factor variables to numeric:

```{r convertions, results = "hide"}

  as.numeric(pull(problem1_df, norm_samp_pos)) 

  as.numeric(pull(problem1_df, vec_char))

  as.numeric(pull(problem1_df, vec_factor))

```

After applying the as.numeric function, the logical vector is assigned values of 1 and 0, with 1 indicating that an element of the sample is greater than 0 and 0 indicating that an element of the sample is not greater than 0. The factor vector is assigned values of one, two, or three, indicating which of the three factor levels an element belongs to. Now that these variables are assigned numeric values, we are able to take the mean.


* convert the logical vector to numeric, and multiply the random sample by the result
 
* convert the logical vector to a factor, and multiply the random sample by the result
 
* convert the logical vector to a factor and then convert the result to numeric, and multiply the random sample by the result
Problem 2

```{r convert_multiply}

  log_num = as.numeric(
    pull(problem1_df, norm_samp_pos))

  log_num * (pull(problem1_df, norm_samp))

  log_fac = as.factor(
    pull(problem1_df, norm_samp_pos))
  
  log_fac * (pull(problem1_df,  norm_samp))
  
  log_fac_num = as.numeric(
      as.factor(pull
                (problem1_df, norm_samp_pos)))
  
  log_fac_num * (pull(problem1_df,  norm_samp))

```

#Problem 2

Create a data frame comprised of:

* x: a random sample of size 500 from a standard Normal distribution
* y: a random sample of size 500 from a standard Normal distribution
* a logical vector indicating whether x + y > 1
* a numeric vector created by coercing the above logical vector
* a factor vector created by coercing the above logical vector

```{r problem2_df}
problem2_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  vec_logical = x + y > 1,
  vec_numeric = as.numeric(vec_logical),
  vec_factor = as.factor(vec_logical)
)
```

There are `r nrow(problem2_df)` rows and `r ncol(problem2_df)` columns in the dataset. The mean, median, and standard deviation of x are `r mean(pull(problem2_df, x))`, `r median(pull(problem2_df, x))` and `r sd(pull(problem2_df, x))`, respectively. The proportion of cases for which x + y > 1 is `r mean(pull(problem2_df, vec_numeric))`

Make a scatterplot of y vs. x; color points using logical variable: 

```{r}
ggplot(problem2_df, aes(x = x, y = y, color = vec_logical)) + geom_point()
```

Make a scatterplot of y vs. x; color points using numeric variable: 

```{r}
ggplot(problem2_df, aes(x = x, y = y, color = vec_numeric )) + geom_point()
```

Make third scatterplot of y vs. x; color points using factor variable: 

```{r}
ggplot(problem2_df, aes(x = x, y = y, color = vec_factor )) + geom_point()
```